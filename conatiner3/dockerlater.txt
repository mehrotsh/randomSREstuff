Hello guys and girls, Raj here back with another Docker video. In this short video, we are going to learn about Docker layers and multi-stage builds, so let's just start with Docker file. So, what is a Docker file? A Docker file is a document that contains all the commands a user could call on the command line to assemble an image for your application. So, in this slide, on the left, I have a sample Python program along with the requirements, and on the right, we have the Docker file to dockerize the container. I'm not going to go deep on what is Docker file and how to dockerize an application, I have a separate video where I started with application running on your local desktop, then we dockerize it on your local desktop, test it out, and then migrate to cloud and then deploy cloud concepts. So, I'm going to link that video up top, check it out if you want. So, if we dive deep into this Docker file, you can see that each line is a command, so when these commands are executed, it creates a layer or intermediate images. For example, when the 'from python:3.8' is run, it creates a layer for this command. Similarly, each command keeps on adding more layers to the container image, and your final Docker container image is the collection of these layers. And when you run your container image to run as a container, on top of these container image layers, a thin writable container layer is created. So, each of the layers adds to the size of the container image. So, let's take a look with our existing program. Okay, I'm going to build the Docker file that we just explained. So, if I run Docker images, you can see currently I have no images, so I'm going to run Docker build minus t, name of the image as sample Python image, to dockerize this application. And then, it's gonna go do all the steps and finally, it says exporting layers. So, let's see what is the size of this container image. So, if I run Docker images, you can see it generated this container image, but the size is 893 megabytes, and this is a pretty straightforward Docker file, right? It's just installing this requirements file, which has only one external library, and then it's copying this Python file and then starting the server.python program. So now, let's look at the layers. To look at the layers, you run Docker history and the name of the container image. So, you can see the first step is getting the base container, which is from Python:3.8. So this takes a lot of space, and then the word directory /code doesn't take any space, and then run this command takes 9.74 megabytes, and finally, the command takes no space. So for this case, most of the space is taken by the base image, which is fetching Python 3.8 container image. So, going back to our container image layers, in your production workload, depending on the commands you are running on the Docker file, each layer will have some size, and it is very critical that you optimize the container image size because when your containers need to scale, or if a running container dies and it needs to be replaced with another running container, one of the big factors of how fast the container orchestrator can create another running container from the image is the size of the container image. So, how do you optimize container image size? So, number one, you can reduce the size of each layer, and number two, reduce the number of layers. So, in our case, the base image is the largest layer. So the base image that we are fetching is the Python 3.8 with a bunch of libraries installed that we don't need, so it is highly recommended to fetch a lightweight image. So one of the super popular approaches is, for example, if you are using a Golang Docker file, instead of fetching, let's say the Golang version 1.7.3, just fetch the Alpine latest container image. It will have the bare minimum libraries installed that can run your Golang code. Now going forward, and this is the multi-stage part, how do you reduce the number of layers? So, if you think about it, at the end of the day, all the Docker file is doing is it is taking your code, installing the dependencies, and compiling it, and then creating an executable, and this is, of course, applicable for compile languages. And once you have this executable, it can run anywhere, right? Because once you have this .exe file, or a .jar file, or the Golang final package file, you do not need to have the code and dependencies anymore. That final artifact is able to run by itself. So your final Docker container image can just
